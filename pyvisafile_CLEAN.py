


## Prerequisites: Pip/Conda install pyvisa==1.14.1, numpy==1.24.3, matplotlib==3.7.2, scipy==1.10.1



import pyvisa
import numpy as np
import matplotlib.pyplot as plt
import matplotlib
matplotlib.use('Qt5Agg')
from scipy.signal import savgol_filter, find_peaks, hilbert
import os

# This is the directory where data is stored, so that the data processing in this python script can be redone using
# the raw measurement data, and this script can be changed when necessary. Make sure a directory with the name 'Mode_Characterization' exists.
output_dir = 'Mode_Characterization'
os.makedirs(output_dir, exist_ok=True)

# Change these parameters for every measurement. Freq is the frequency as generated by the function generator. Location is
# the location of the measurement along the cantilever, measuring from the root in micrometers.
# Attempt can be used if you want to redo a measurement, without overwriting the previous data.
freq = 14
location = 200
attempt = 1

# Do you want to do a measurement or do you want to use the data from a previous measurement?
make_new_measurement = False

# Do you want to save the data? Warning: this might overwrite data from a previous measurement with the same name. Use
# the attempt parameter to create multiple versions of the same measurement.
save_data = False

if make_new_measurement == True:

    # Connect tot the pyVISA driver
    rm = pyvisa.ResourceManager()

    # List all connected devices. Use this to find the correct device name.
    print(rm.list_resources())

    # Connect to the device. Make sure the name in the open_resource function is the same as the name of the device
    # found in the previous step.
    my_instrument = rm.open_resource('USB0::0x1AB1::0x0488::DS1BA125100508::INSTR')

    # Set the timeout of the device to 25 seconds
    my_instrument.timeout = 25000

    # Test connection by asking for the device ID. *IDN? asks the oscilloscope for its ID, and read() reads the response.
    my_instrument.write('*IDN?')
    print(my_instrument.read())

    # Set the oscilloscope to average mode, which averages the signal over time. This is useful to reduce noise.
    my_instrument.write(':ACQ:TYPE AVERage')
    my_instrument.write(':ACQ:AVER 32') # You can change the number of averages here.

    # Set the waveform format to ASCII. This is the format in which the oscilloscope will send the data.
    my_instrument.write(':WAV:FORM ASC')
    print(my_instrument.query(':WAV:FORM?'))

    # Set the oscilloscope data to RAW, and increase the number of points to 16840. This is the maximum number of points
    my_instrument.write(':WAV:POIN:MODE RAW')
    my_instrument.write(':WAV:POIN 16840')
    print(my_instrument.query(':WAV:POIN?'))

    # Stop the oscilloscope to load the data.
    my_instrument.write(':STOP')

    # Get the data from channel 1 and channel 2.
    my_instrument.write(':WAV:DATA? CHAN1')
    data = my_instrument.read_raw().decode('UTF-8')[12:].split(',')

    my_instrument.write(':WAV:DATA? CHAN2')
    data2 = my_instrument.read_raw().decode('UTF-8')[12:].split(',')

    # Start the oscilloscope again.
    my_instrument.write(':RUN')

    # Get the time increment from the oscilloscope.
    dt = float(my_instrument.query(':WAVeform:XINCrement?'))

    # Convert the data to numpy arrays.
    input_voltage = np.array(data, dtype=float)
    output_voltage = np.array(data2, dtype=float)
    time = np.arange(0, len(input_voltage) * dt, dt)
else:
    # Load the data from a previous measurement.
    datafile = np.load(os.path.join(output_dir, f'{freq}data{location}a{attempt}.npz'))
    time = datafile['time']
    input_voltage = datafile['input_voltage']
    output_voltage = datafile['output_voltage']
    filtered_input = datafile['filtered_input']
    filtered_output = datafile['filtered_output']
    hilbert_time = datafile['hilbert_time']
    phase_over_time = datafile['phase_over_time']
    Deltax = datafile['Deltax']

# Filter the input voltage signal using a Savitzky-Golay filter. You can change the window_length if you see in the plot
# that the filtered signal does not follow the input signal well.
window_length = 500
filtered_input = savgol_filter(input_voltage, window_length, 3)

# Find the peaks and troughs in the input signal. This is used to determine the interval over which the DeltaX is calculated.
inputpeaks = find_peaks(filtered_input, prominence=0.1)
inputtroughs = find_peaks(-filtered_input, prominence=0.03)
index_length_beween_peak_and_trough = np.abs(inputpeaks[0][0] - inputtroughs[0][0])

# Calculate the window size for the output signal. This is used to filter the output signal. You might need to change
# the constant factor in this expression if you see that the filtered output signal does not follow the unfiltered output
# signal well. This is important so make sure to check this in the plot.
windowsize_output = int((1/4)*index_length_beween_peak_and_trough)

# Filter the output signal using a Savitzky-Golay filter.
filtered_output = savgol_filter(output_voltage, windowsize_output, 3)

# Create plots
fig, ax = plt.subplots(3,1, sharex='all', figsize=(6,6))
ax[0].plot(time, input_voltage)
ax[1].plot(time, output_voltage)
ax[0].plot(time, filtered_input)
ax[1].plot(time, filtered_output)
ax[0].vlines(time[inputpeaks[0]], 0, 1, colors='r')
ax[0].vlines(time[inputtroughs[0]], 0, 1, colors='g')

# It is possible to calculate DeltaX between the first two peaks/throughs or between the first peak and the first trough.
# Because the distance between two adjacent peaks/througs is twice the distance between a peak and an adjacent trough,
# we need to compensate for this in the calculation of DeltaX. This is done by the divide_by_2 variable. This makes fair
# comparison between the two methods possible.
divide_by_2 = 1

# These variables will store the start-/end-indices of the interval over which the DeltaX is calculated.
index0=0
index1=0

# Set the data for the Hilbert transform. For now these are just the filtered output signal and the time. If you want to
# modify this, you can change the data_to_be_hilbertized and hilbert_time variables.
data_to_be_hilbertized = filtered_output
hilbert_time = time

# This if-else statement determines between which peaks/troughs the DeltaX is calculated.
if inputpeaks[0][0] > inputtroughs[0][0]:
    if len(inputtroughs[0]) > 1:
        divide_by_2 = 2
        index0=inputtroughs[0][0]
        index1 = inputtroughs[0][1]
    else:
        index0 = inputtroughs[0][0]
        index1 = inputpeaks[0][0]
else:
    if len(inputpeaks[0]) > 1:
        divide_by_2 = 2
        index0 = inputpeaks[0][0]
        index1 = inputpeaks[0][1]
    else:
        index0 = inputpeaks[0][0]
        index1 = inputtroughs[0][0]

# Calculate the Hilbert transform of the data. To be fair, that is not really what happens. The scipy.hilbert() function
# actually calculates the analytic signal of the data. The phase of this analytic signal is itself a signal that
# gives the instantaneous phase of the input data over time. This means that if the input data is periodic, then over every period
# of the input data, there is a difference of 2pi in the instantaneous phase signal. Because the hilbert_data is automatically
# wrapped between -pi and pi, we also need to unwrap the phase signal. This will make sure that the instantaneous phase signal continues
# after pi to increase further, rather than making a jump to -pi and increasing from there.
hilbert_data = np.angle(hilbert(data_to_be_hilbertized))
hilbert_data2 = np.unwrap(hilbert_data, discont=np.pi)

# There might still be some jumps in the unwrapped phase signal. The following code removes these jumps.
hilbert_diff = []
for i, h in enumerate(hilbert_data2):
    if i != len(hilbert_data2)-1:
        hilbert_diff.append(hilbert_data2[i+1] - hilbert_data2[i])
        if np.abs(hilbert_data2[i+1] - hilbert_data2[i]) > 0.5*np.pi:
            hilbert_data2[i+1:] = hilbert_data2[i+1:] - np.pi*np.sign(hilbert_data2[i+1] - hilbert_data2[i])

# Calculate the phase over time. This is done by integrating the absolute value of the derivative of the unwrapped phase signal.
# This is done so that movements backwards in the phase signal and movements forwards in the phase signal each contribute to the
# total phase over time.
phase_over_time = np.array([np.trapz(np.abs(np.gradient(hilbert_data2, hilbert_time))[0:j], hilbert_time[0:j]) for j, t in
                   enumerate(hilbert_time)])[index0:index1]
hilbert_time2 = hilbert_time[index0:index1]

# Plot the phase over time signal. Divide by 2pi so that every one cycle in the output signal corresponds to an increase of 1.
ax[2].plot(hilbert_time2, phase_over_time*(1/(2*np.pi)))

# Calculate the displacement.
Delta_phi = phase_over_time[-1] - phase_over_time[0]
Deltax = Delta_phi * 635e-9 / (2 * divide_by_2 * 2*np.pi)

# Show the plots and provide the calculated DeltaX.
ax[2].set_title(f'{2*Deltax*1000000} micrometer ')
plt.show()
print(f'{2*Deltax*1000000} micrometer')

# Save the data if necessary.
if save_data == True:
    np.savez(os.path.join(output_dir, f'{freq}data{location}a{attempt}.npz'), time=time, input_voltage=input_voltage, output_voltage=output_voltage, filtered_input=filtered_input, filtered_output=filtered_output, hilbert_time=hilbert_time, phase_over_time=phase_over_time, Deltax=Deltax)

